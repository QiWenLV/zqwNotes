## Linux会话与进程

在Linux中，当用户注销（logout）或者网络断开时，终端会收到 HUP（hangup）信号从而关闭其所有子进程。

---

**为什么会这样呢？**

有这样几个概念： 

- 进程组（process group）：一个或多个进程的集合，每一个进程组有唯一一个进程组ID，即进程组长进程的ID。 
- 会话期（session）：一个或多个进程组的集合，有唯一一个会话期首进程（session leader）。

会话期ID为首进程的ID。 会话期可以有一个单独的控制终端（controlling terminal）。

当前与终端交互的进程称为**前台进程组**。其余进程组称为**后台进程组**。 

**挂断过程：**

当终端接口检测到网络连接断开，将挂断信号发送给控制进程（会话期首进程）。 如果会话期首进程终止，则该信号发送到该会话期前台进程组。 一个进程退出导致一个孤儿进程组中产生时，如果任意一个孤儿进程组进程处于STOP状态，发送SIGHUP和SIGCONT信号到该进程组中所有进程。 因此当网络断开或终端窗口关闭后，控制进程收到SIGHUP信号退出，会导致该会话期内其他进程退出。

因此，我们的解决办法就有两种途径：要么让进程忽略 HUP 信号，要么让进程运行在新的会话里从而成为不属于此终端的子进程。

## 后台运行

常用的后台运行命令有：`nphup`、`setsid`

### nohup

原理是让终端直接忽略HUP信号。

```sh
nohup ping www.baidu.com &
```

1. 后缀 & 是让其后台运行，只有使用exit退出终端进程才不会停止，如果**直接连接断开任务依旧会终止**

2. 本应打印到控制台的日志会打印在nohup.out文件中

3. 另一种写法重定向输出位置（比如黑洞）

   ```sh
   nohup command >/dev/null 2>&1 &
   ```

4. 只想保留错误信息

   ```
   nohup command >/dev/null 2>err.log & 
   ```

注意：Linux的重定向，其中0、1、2分别是标准输入、标准输出、标准错误输出，用来指定需要重定向的标准输入输出。默认情况下是标出输出，也就是1 。例如我们而上文提到的 2>&1 是 将错误信息重定向到标准输出。

### setsid

上面讲的忽略SIGHUP信号，那如果我们给它换个父进程，这时候我们就可以用到`setsid` ，用法：

```sh
setsid command
```

这里任务的父进程ID变成了1，也就是`init`进程。这样就不会随着连接中断而挂掉了。

```
~ setsid ping www.baidu.com
~ ps -ef | grep ping
moma      6186     1  0 09:55 ?        00:00:00 ping google.com
```

这里还有一个关于 subshell 的小技巧。我们知道，将一个或多个命名包含在“()”中就能让这些命令在子 shell 中运行中，从而扩展出很多有趣的功能，我们现在要讨论的就是其中之一。

当我们将"&"也放入“()”内之后，我们就会发现所提交的作业并不在作业列表中，也就是说，是无法通过`jobs`来查看的。

```sh
(ping command &)
```

实现原理其实也是更换父进程

## 使用Screen工具

screen 提供了 ANSI/VT100 的终端模拟器，使它能够在一个真实终端下运行多个全屏的伪终端

使用 screen 很方便，有以下几个常用选项：

- 用`screen -dmS *session name*`来建立一个处于断开模式下的会话（并指定其会话名）。
- 用`screen -ls `来列出所有会话。
- 用`screen -r *session name*`来重新连接指定会话。
- 用快捷键`CTRL-ad `来暂时断开当前会话， `CTRL+d`结束当前的会话。



## 使用Disown工具

如果一个命令，我们在执行后才知道它的执行时间非常长，想将他转为后台执行，那么可以通过disown工具来完成

可以看出，我们可以用如下方式来达成我们的目的。

- 用`disown -h *jobspec*`来使**某个进程**忽略HUP信号。
- 用`disown -ah `来使**所有的进程**都忽略HUP信号。
- 用`disown -rh `来使**正在运行的进程**忽略HUP信号



## 其他技巧

##### 灵活运用 CTRL-z

在我们的日常工作中，我们可以用 `CTRL-z` 来将当前进程挂起到后台暂停运行，执行一些别的操作，然后再用` fg` 来将挂起的进程重新放回前台（`jobs`命令来查询它的作业号，也可用 `bg jobspec`来将挂起的进程放在后台）继续运行。这样我们就可以在一个终端内灵活切换运行多个任务，这一点在调试代码时尤为有用。因为将代码编辑器挂起到后台再重新放回时，光标定位仍然停留在上次挂起时的位置，避免了重新定位的麻烦

```sh
ctrl+c 	#结束当前任务
ctrl+z 	#挂起当前任务
jobs -l #查看任务，返回任务编号 和 进程号
bg %n 	#编号n的任务转向后台运行，实际上bg n 也可以
fg %n 	#编号n的任务转向前台运行
```

