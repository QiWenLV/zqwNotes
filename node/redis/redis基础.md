## redis的通讯协议

redis的通讯协议是**文本协议**

Redis服务器与客户端通过RESP（*REdis Serialization Protocol*）协议通信，没错，文本协议确实是会浪费流量，不过它的优点在于直观，非常的简单，解析性能好。

客户端的命令格式：

- 简单字符串 Simple Strings, 以 "+"加号 开头
- 错误 Errors, 以"-"减号 开头
- 整数型 Integer， 以 ":" 冒号开头
- 大字符串类型 Bulk Strings, 以 "$"美元符号开头
- 数组类型 Arrays，以 "*"星号开头

## redis的事务

传统事务ACID是指：1.原子性 2.一致性 3.隔离性 4.持久性

Redis事务是一个单独的隔离操作：**事务中的所有命令都会序列化、按顺序地执行，事务在执行的过程中，不会被其他客户端发送来的命令请求所打断**

Redis事务的主要作用就是串联多个命令防止别的命令插队

### 事务具体操作

redis事务分为两个阶段

1. 组队阶段：
   - 从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行。直到输入Exec后，Redis将会之前的命令队列中的命令依次执行
   - 组队过程中可以通过discard来放弃组队
2. 执行阶段
   - 在组队阶段有语句直接报错了。在进入执行阶段会全部保持，一个都过不了
   - 在组队阶段没有语句报错，但是有的语句是运行错误。那么执行阶段其他的语句都可以**执行成功**，有错的语句执行不了。
   - **没有回滚机制**

### 与传统事务的比较

- redis具备了一定的原子性，但不支持回滚
- redis不具备ACID中一致性的概念（或者说redis在设计就无视这点）
- redis具备隔离性
- redis通过一定策略可以保证持久性

## redis的锁

冲突现象：
有一个值为100，一个连接想加20，一个连接想加30， 最后的结果为130

- 悲观锁*Pessimistic Lock*
  连接1去拿数据的时候，担心别的连接会修改，所以每次在拿数据的时候都会将数据上锁。在连接1处理数据的时候，连接2想拿这个数据就会block(阻塞)，直到连接1处理完数据，给数据解锁。
  传统的关系型数据库里面就用到了很多这种锁机制，比如行锁，表锁，读锁，写锁等。都是在操作之前先上锁
- 乐观锁*Optimistic Lock*
  连接1每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是会记下数据的版本号，在自己处理完数据之后，会判断一下再此期间其他人有没有去更新这个数据，如何更新则读新数据再次处理。
  乐观锁适用于多读的应用类型，这样可以提高吞吐量，Redis就是利用这种check-and-set机制实现事务的

```sh
watch key       为key添加乐观锁
unwatch         取消乐观锁
```

### redis的持久化



### redis内存的开源节流

### redis过期删除策略