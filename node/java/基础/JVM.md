## 一、基本概念

JRE中包含着JVM

**Write Once Run EveryWhere**： 一次编译，可以到处运行，但是JVM是分操作系统的。在不同的操作系统上运行不同的JVM，JVM就是中间的一个适配器。所以java是跨平台的。



**内存管理**：new的底层实现

### JVM概念

JVM是Java Virtual Machine的简称。意为Java虚拟机

虚拟机

- 指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统

JVM使用软件模拟Java字节码的指令集

#### jdk的版本

2004年发布JDK 1.5即JDK 5、J2SE 5、Java 5

- 泛型
- 注解

- 装箱
- 枚举
- 可变长的参数
- Foreach循环

JDK 1.6JDK 6

- 脚本语言支持
- JDBC 4.0
- Java编译器API

2011年JDK 7发布

- 延误项目推出到JDK 8

- G1

- 动态语言增强

- 64位系统中的压缩指针
- NIO 2.0

2014年JDK 8发布

- Lambda表达式
- 语法增强Java类型注解

2016年JDK 9

- 模块化

## 二、JVM运行机制

### JVM启动流程

![](https://wendy-image.oss-cn-shanghai.aliyuncs.com/19-06-13/1560404968214.png)

### JVM基本结构

![](https://wendy-image.oss-cn-shanghai.aliyuncs.com/19-06-13/1560405001035.png)

#### PC寄存器

每个线程拥有一个PC寄存器，在线程创建时创建

指向下一条指令的地址，执行本地方法时， PC的值为undefined

#### 方法区

保存装载的类信息

- 类型的常量池
- 字段，方法信息
- 方法字节码

通常和永久区(Perm) 关联在一起

#### 堆

和程序开发密切相关，应用系统对象都保存在Java堆中，所以线程共享Java堆。

对分代GC来说，堆也是分代的。GC的主要工作区间

#### 栈

线程私有的。栈由一系列帧组成(因此Java栈也叫做帧栈)

帧保存一个方法的局部变量、操作数栈、常量池指针

每一次方法调用创建一个帧，并压栈

栈的结构：

- 局部变量表：存在与帧中，包含方法的参数和局部变量。

    ```
    public int runInstance(int i, long l, float f, Object o){
        return 0;
    }
    ```

    以上代码的局部变量表如下

    | 0    | reference this           |
    | ---- | ------------------------ |
    | 1    | int    int    i          |
    | 2    | long    long     l       |
    |      |                          |
    | 3    | float    float     f     |
    | 4    | reference    Object    o |

    注意：一个槽位可容纳32位的数据，所以long类型需要占用两个槽位。对象只是一个引用（指针），指向堆空间，所以也只有32位。只有非静态方法的第一个是this的引用。

- 函数调用组成帧栈：当有方法调用时。就会形成一个帧，进行压栈。一个方法运行完毕就进行出栈。

- 操作数栈：Java中没有寄存器，**Java中所有的参数传递都是依靠栈**

- 栈上分配：如果直接new出对象，那么对象是存在在堆中的。也叫堆上分配。每次需要手动清理空间。栈上分配就是在方法内部声明对象，函数调用完时自动清理。

    栈上分配的优势：

    - 小对象（几十bytes）在没有逃逸的情况下，可以直接分配在栈上
    - 直接分配在栈上，可以自动回收，**减轻GC压力**
    - 大对象或者逃逸对象无法栈上分配

### 内存模型

分为五个部分

- 方法区
- 堆
- 本地方法栈
- 虚拟机栈
- 程序计数器（寄存器）

常量，静态变量是存放在方法区中的

成员变量是存放在堆中的

---

每个线程有一个工作内存和主存独立

![](https://wendy-image.oss-cn-shanghai.aliyuncs.com/19-06-13/1560408185010.png)

主存是共享的，线程的本地内存中的变量是最新的，但是可能会与共享中的变量有一定的时延或者误差。这个问题可以用**volatile关键字**解决。

可见性：是指一个线程修改变量之后，其他线程可以**立即**知道

保证可见性的方法：

- volatile
- synchronized（unlock之前，写变量回主存）
- final（一旦初始化完成，其他线程就可见）