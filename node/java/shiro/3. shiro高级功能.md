[TOC]

## 一、编码/加密



## 二、会话管理

Shiro提供了完整的企业级会话管理功能，不依赖于底层容器（如web容器tomcat），不管JavaSE还是JavaEE环境都可以使用，提供了会话管理、会话事件监听、会话存储/持久化、容器无关的集群、失效/过期支持、对Web的透明支持、SSO单点登录的支持等特性。即直接使用Shiro的会话管理可以直接替换如Web容器的会话管理。

### 1. 常用方法

获取会话：

```
Subject subject = SecurityUtils.getSubject();  
Session session = subject.getSession();   
```

常用方法：

```java
session.getId();  	//获取当前会话的唯一标识。
session.getHost();  //获取当前Subject的主机地址

//获取/设置当前Session的过期时间；如果不设置默认是会话管理器的全局过期时间。
session.getTimeout();  
session.setTimeout(毫秒);   

//获取会话的启动时间及最后访问时间；
session.getStartTimestamp();  
session.getLastAccessTime();  

session.touch();  	//更新会话最后访问时间
session.stop();   	//销毁会话

//利用会话传递一些数据
session.setAttribute("key", "123");  
Assert.assertEquals("123", session.getAttribute("key"));  
session.removeAttribute("key");  
```

### 2. 会话管理器

会话管理器管理着应用中所有Subject的会话的创建、维护、删除、失效、验证等工作。是Shiro的核心组件，顶层组件SecurityManager直接继承了SessionManager，且提供了SessionsSecurityManager实现直接把会话管理委托给相应的SessionManager，DefaultSecurityManager及DefaultWebSecurityManager默认SecurityManager都继承了SessionsSecurityManager。

SecurityManager提供了如下接口：

```java
Session start(SessionContext context); 	//启动会话  
Session getSession(SessionKey key) throws SessionException; //根据会话Key获取会话   
boolean isServletContainerSessions();	//是否使用Servlet容器的会话  
```

Shiro提供了三个默认实现：

- **DefaultSessionManager**：DefaultSecurityManager使用的默认实现，用于JavaSE环
- **ServletContainerSessionManager**：DefaultWebSecurityManager使用的默认实现，用于Web环境，其直接使用Servlet容器的会话；
- **DefaultWebSessionManager**：用于Web环境的实现，可以替代ServletContainerSessionManager，自己维护着会话，直接废弃了Servlet容器的会话管理。

### 3. 会话管理案例

更改ShiroConfig

```java
//为了能够在Spring Boot中使用SessionDao，我们在ShiroConfig中配置该Bean：
@Bean
public SessionDAO sessionDAO() {
    MemorySessionDAO sessionDAO = new MemorySessionDAO();
    return sessionDAO;
}

//如果使用的是Redis作为缓存实现，那么SessionDAO则为RedisSessionDAO：
@Bean
public RedisSessionDAO sessionDAO() {
    RedisSessionDAO redisSessionDAO = new RedisSessionDAO();
    redisSessionDAO.setRedisManager(redisManager());
    return redisSessionDAO;
}
```

在Shiro中，`SessionDao`通过`org.apache.shiro.session.mgt.SessionManager`进行管理，所以继续在ShiroConfig中配置`SessionManager`：

```java
@Bean
public SessionManager sessionManager() {
    DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();
    Collection<SessionListener> listeners = new ArrayList<SessionListener>();
    listeners.add(new ShiroSessionListener());
    sessionManager.setSessionListeners(listeners);
    sessionManager.setSessionDAO(sessionDAO());
    return sessionManager;
}
```

 其中`ShiroSessionListener`为`org.apache.shiro.session.SessionListener`接口的手动实现，所以接下来定义一个该接口的实现：

```java
public class ShiroSessionListener implements SessionListener{
    private final AtomicInteger sessionCount = new AtomicInteger(0);
    @Override
    public void onStart(Session session) {
        sessionCount.incrementAndGet();
    }
    @Override
    public void onStop(Session session) {
        sessionCount.decrementAndGet();
    }
    @Override
    public void onExpiration(Session session) {
        sessionCount.decrementAndGet();
    }
}
```

其维护着一个原子类型的Integer对象，用于统计在线Session的数量。

定义完SessionManager后，还需将其注入到SecurityManager中：

```java
@Bean  
public SecurityManager securityManager(){  
    DefaultWebSecurityManager securityManager =  new DefaultWebSecurityManager();
    securityManager.setRealm(shiroRealm());
    ...
    securityManager.setSessionManager(sessionManager());
    return securityManager;  
}
```

创建实体类，来描述用户的在线基本信息

```java
public class UserOnline implements Serializable{
	
    private static final long serialVersionUID = 3828664348416633856L;
    // session id
    private String id;
    // 用户id
    private String userId;
    // 用户名称
    private String username;
    // 用户主机地址
    private String host;
    // 用户登录时系统IP
    private String systemHost;
    // 状态
    private String status;
    // session创建时间
    private Date startTimestamp;
    // session最后访问时间
    private Date lastAccessTime;
    // 超时时间
    private Long timeout;
}
```

创建一个Service接口，包含查看所有在线用户和根据SessionId踢出用户抽象方法：

```java
public interface SessionService {
    List<UserOnline> list();
    boolean forceLogout(String sessionId);
}
```

其具体实现：

```java
@Service("sessionService")
public class SessionServiceImpl implements SessionService {
    @Autowired
    private SessionDAO sessionDAO;

    @Override
    public List<UserOnline> list() {
        List<UserOnline> list = new ArrayList<>();
        Collection<Session> sessions = sessionDAO.getActiveSessions();
        for (Session session : sessions) {
            UserOnline userOnline = new UserOnline();
            User user = new User();
            SimplePrincipalCollection principalCollection = new SimplePrincipalCollection();
            if (session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY) == null) {
                continue;
            } else {
                principalCollection = (SimplePrincipalCollection) session
                	.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);
                user = (User) principalCollection.getPrimaryPrincipal();
                userOnline.setUsername(user.getUserName());
                userOnline.setUserId(user.getId().toString());
            }
            userOnline.setId((String) session.getId());
            userOnline.setHost(session.getHost());
            userOnline.setStartTimestamp(session.getStartTimestamp());
            userOnline.setLastAccessTime(session.getLastAccessTime());
            Long timeout = session.getTimeout();
            if (timeout == 0l) {
                userOnline.setStatus("离线");
            } else {
                userOnline.setStatus("在线");
            }
            userOnline.setTimeout(timeout);
            list.add(userOnline);
        }
        return list;
    }

    @Override
    public boolean forceLogout(String sessionId) {
        Session session = sessionDAO.readSession(sessionId);
        session.setTimeout(0);
        return true;
    }
}
```

通过SessionDao的`getActiveSessions()`方法，我们可以获取所有有效的Session，通过该Session，我们还可以获取到当前用户的Principal信息。

值得说明的是，当某个用户被踢出后（Session Time置为0），该Session并不会立刻从ActiveSessions中剔除，所以我们可以通过其timeout信息来判断该用户在线与否。

如果使用的Redis作为缓存实现，那么，`forceLogout()`方法需要稍作修改：

```java
@Override
public boolean forceLogout(String sessionId) {
    Session session = sessionDAO.readSession(sessionId);
    sessionDAO.delete(session);
    return true;
}
```

## 三、缓存机制

## 四、单点登录

## 六、授予身份及切换身份

## 五、多项目集中权限管理及分布式会话