## 概述

> 作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。

**因为重量级的对象，不希望反复的创建，所以使用单例模式。**

单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。

## 基本定义

所谓单例模式就是确保某一个类只有一个实例，并且提供一个全局访问点。通过单例模式可以保证系统中一个类中只有一个实例。
单例模式有以下特点：
　　1、单例类只能有一个实例。
　　2、单例类必须自己创建自己的唯一实例。
　　3、单例类必须给所有其他对象提供这一实例。

## 模式结构



![](https://wendy-image.oss-cn-shanghai.aliyuncs.com/19-04-04/1554360143443.png)

单例模式仅有一个角色Singleton。


## 代码实现

### 饿汉式

```java
/**
 * 饿汉式(静态变量)
 */
class Singleton {
    //私有化构造
    private Singleton(){}

    private final static Singleton instance = new Singleton();

    public static Singleton getInstance(){
        return instance;
    }
}
```

```java
/**
 * 饿汉式(静态代码块)
 */
class Singleton {
    //私有化构造
    private Singleton(){}
    private static Singleton instance;

    static {
        instance = new Singleton();
    }
    public static Singleton getInstance(){
        return instance;
    }
}
```

- 优点：写法比较简单。就是在**类装载的时候就完成实例化**。避免了线程同步问题
- 缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费

这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance就没有达到**lazy loading**的效果

**结论：**饿汉式是典型的**空间换时间**这种单例模式可用， **可能**造成内存浪费

### 懒汉式（线程不安全）

```java
/**
 * 懒汉式(线程不安全)
 */
class Singleton {
    
    private Singleton(){}
    private static Singleton instance;
    
    public static Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}
```

在调用的时候，才初始化单例

- 优点：能起到Lazy Loading的效果
- 缺点：只能在单线程下使用，如果有一个线程进入if，还没创建完对象，其他线程也进入了if，这种情况导致多例。

生产环境不要使用

### 懒汉式（线程安全，同步方法）

```java
/**
 * 懒汉式(线程安全，同步方法)
 */
class Singleton {

    private Singleton(){}
    private static Singleton instance;

    public static synchronized Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}
```

相比之前，就在在方法上加了synchronized关键字

- 优点：解决了线程不安全的问题
- 缺点：每次获取单例，都需要进行同步。实际上这个同步只需要进行一次就行了。同步方法效率太低


总结：懒汉式是典型的**时间换空间**,就是每次获取实例都会进行判断，看是否需要创建实例，浪费判断的时间。当然，如果一直没有人使用的话，那就不会创建实例，则节约内存空间。

由于懒汉式的实现是线程安全的，这样会降低整个访问的速度，而且每次都要判断。那么有没有更好的方式实现呢？

### 双重检查加锁

可以使用“双重检查加锁”的方式来实现，就可以既实现线程安全，又能够使性能不受很大的影响。

所谓“双重检查加锁”机制，指的是：并不是每次进入getInstance方法都需要同步，而是先不同步，进入方法后，先检查实例是否存在，如果不存在才进行下面的同步块，这是第一重检查，进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。

“双重检查加锁”机制的实现会使用关键字volatile，它的意思是：被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。

```java
public class Singleton {
    private volatile static Singleton instance = null;
    private Singleton(){}
    public static Singleton getInstance(){
        //先检查实例是否存在，如果不存在才进入下面的同步块
        if(instance == null){
            //同步块，线程安全的创建实例
            synchronized (Singleton.class) {
                //再次检查实例是否存在，如果不存在才真正的创建实例
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

这种实现方式既可以实现线程安全地创建实例，而又不会对性能造成太大的影响。它只是第一次创建实例的时候同步，以后就不需要同步了，从而加快了运行速度。

提示：由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。因此一般建议，没有特别的需要，不要使用。也就是说，虽然可以使用“双重检查加锁”机制来实现线程安全的单例，但并不建议大量采用，可以根据情况来选用。

### 静态内部类

这个模式综合使用了Java的类级内部类和多线程缺省同步锁的知识，很巧妙地同时实现了延迟加载和线程安全。
**类级内部类**
　　简单点说，**类级内部类指的是，有static修饰的成员式内部类**。如果没有static修饰的成员式内部类被称为对象级内部类。

类级内部类相当于其外部类的static成分，它的对象与外部类对象间不存在依赖关系，因此可直接创建。而对象级内部类的实例，是绑定在外部对象实例中的。

类级内部类中，可以定义静态的方法。在静态方法中只能够引用外部类中的静态成员方法或者成员变量。

类级内部类相当于其外部类的成员，只有在第一次被使用的时候才被会装载。

**多线程缺省同步锁**
　　在多线程开发中，为了解决并发问题，主要是通过使用synchronized来加互斥锁进行同步控制。但是在某些情况中，JVM已经隐含地为您执行了同步，这些情况下就不用自己再来进行同步控制了。这些情况包括：

- 1.由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时
- 2.访问final字段时
- 3.在创建线程之前创建对象时
- 4.线程可以看见它将要处理的对象时

**线程安全**

如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。

或者说：一个类或者程序所提供的接口对于线程来说是原子操作，或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题，那就是线程安全的。
**解决方案的思路**
　　要想很简单地实现线程安全，可以采用静态初始化器的方式，它可以由JVM来保证线程的安全性。比如前面的饿汉式实现方式。但是这样一来，不是会浪费一定的空间吗？因为这种实现方式，会在类装载的时候就初始化对象，不管你需不需要。
如果现在有一种方法能够让类装载的时候不去初始化对象，那不就解决问题了？一种可行的方式就是采用类级内部类，在这个类级内部类里面去创建对象实例。这样一来，只要不使用到这个类级内部类，那就不会创建对象实例，从而同时实现延迟加载和线程安全。

示例代码如下：

```java
public class Singleton {
   
   private Singleton(){}
   /**
    *    类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例
    *    没有绑定关系，而且只有被调用到时才会装载，从而实现了延迟加载。
    */
   private static class SingletonHolder{
       /**
        * 静态初始化器，由JVM来保证线程安全
        */
       private static final Singleton INSTANCE = new Singleton();
   }
   
   public static Singleton getInstance(){
       return SingletonHolder.INSTANCE;
   }
}
```

当getInstance方法第一次被调用的时候，它第一次读取SingletonHolder.instance，导致SingletonHolder类得到初始化；而这个类在装载并被初始化的时候，会初始化它的静态域，从而创建Singleton的实例，由于是静态的域，因此只会在虚拟机装载类的时候初始化一次，并由虚拟机来保证它的线程安全性（**JVM的类装载过程是线程安全的**）。

优点：

1. 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。
2. 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。
3. 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。

### 枚举单例

>  单元素的枚举类型已经成为实现Singleton的最佳方法。

用枚举来实现单例非常简单，只需要编写一个包含单个元素的枚举类型即可。使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。

```
class Resource{
}

public enum SomeThing {
    INSTANCE;
    private Resource instance;
    SomeThing() {
        instance = new Resource();
    }
    public Resource getInstance() {
        return instance;
    }
}
```

上面的类Resource是我们要应用单例模式的资源，具体可以表现为网络连接，数据库连接，线程池等等。
获取资源的方式很简单，只要 SomeThing.INSTANCE.getInstance() 即可获得所要实例。

下面我们来看看单例是如何被保证的：

首先，在枚举中我们明确了构造方法限制为私有，在我们访问枚举实例时会执行构造方法，同时每个枚举实例都是static final类型的，也就表明只能被实例化一次。在调用构造方法时，我们的单例被实例化。
也就是说，因为enum中的实例被保证只会被实例化一次，所以我们的INSTANCE也被保证实例化一次。
可以看到，枚举实现单例还是比较简单的，除此之外我们再来看一下Enum这个类的声明：

```
public abstract class Enum<E extends Enum<E>>
        implements Comparable<E>, Serializable
```

可以看到，枚举也提供了序列化机制。某些情况，比如我们要通过网络传输一个数据库连接的句柄，会提供很多帮助。

## 优劣

### 优点

- 节约了系统资源。由于系统中只存在一个实例对象，对与一些需要频繁创建和销毁对象的系统而言，单例模式无疑节约了系统资源和提高了系统的性能。
- 因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。

### 缺点

- 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。
- 单例类的职责过重，在一定程度上违背了“单一职责原则”。

## 适用场景

下列几种情况可以使用单例模式。

- 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。
- 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。

## 总结

- 单例模式中确保程序中一个类最多只有一个实例。
- 单例模式的构造器是私有了，而且它必须要提供实例的全局访问点。
- 单例模式可能会因为多线程的问题而带来安全隐患。