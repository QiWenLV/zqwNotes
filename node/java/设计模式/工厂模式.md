## 简单工厂模式

先看一个需求

看一个披萨的项目：要便于披萨种类的扩展，要便于维护

1. 披萨的种类很多(比如 GreekPizz、CheesePizz 等)
2. 披萨的制作有 prepare，bake, cut, box
3. 完成披萨店订购功能。

```java
/**
 * 披萨抽象类
 */
public abstract class Pizza {
    protected String name;  //名字

    //准备原材料，不同的披萨是不一样的
    public abstract void prepare();
    //烘烤
    public void bake(){
        System.out.println(name + "baking;");
    }
    //切割
    public void cut(){
        System.out.println(name + "cutting;");
    }
    //打包
    public void box(){
        System.out.println(name + "boxing;");
    }
    public void setName(String name){
        this.name = name;
    }
}
```

种类不同的产品

```java
public class GreekPizza extends Pizza {
    @Override
    public void prepare() {
        System.out.println(" 准备希腊");
    }
}

public class CheesePizza extends Pizza {
    @Override
    public void prepare() {
        System.out.println(" 准备奶酪");
    }
}
```

### 什么是简单工程模式

1. 简单工厂模式是属于创建型模式，是工厂模式的一种。 简单工厂模式是由一个工厂对象决定创建出哪一 种产品类 的实例。简单工厂模式是工厂模式家族中最简单实用的模式
2. 简单工厂模式：定义了一个创建对象的类，由这个类来 封装实例化对象的行为为(代码)
3. 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式

工厂类

```java
public class SimpleFactory {
    //创建工厂
    public Pizza createPizza(String name){
        Pizza pizza = null;
        if ("cheese".equals(name)) {
            pizza =  new CheesePizza();
            pizza.setName(" 奶酪披萨");
        } else if("greek".equals(name)){
            pizza =  new GreekPizza();
            pizza.setName(" 希腊披萨");
        }
        return pizza;
    }
}
```

订单类(可以直接将工厂改造为静态或者单例，方便使用)

```java
public class OrderPizza {

    private SimpleFactory simpleFactory;
    private Pizza pizza = null;

    //构造器(聚合)
    public OrderPizza(SimpleFactory simpleFactory) {
        setSimpleFactory(simpleFactory);
    }

    public void setSimpleFactory(SimpleFactory simpleFactory){
        String orderType = "";
        this.simpleFactory = simpleFactory;
        do {
            //获取用户输入的pizza类型
            orderType = getType();
            pizza = this.simpleFactory.createPizza(orderType);

            //输出pizza
            if(Objects.nonNull(pizza)){
                pizza.prepare();
                pizza.bake();
                pizza.cut();
                pizza.bake();
            } else {
                System.out.println(" 订购披萨失败");
            }
        } while (true);
    }
}
```

主类测试

```java
public static void main(String[] args) {
    new OrderPizza(new SimpleFactory());
    System.out.println("退出程序~");
}
```

## 工厂方法模式

新的需求：

披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪pizza、北京的胡椒pizza 或者是伦敦的奶酪pizza、伦敦的胡椒pizza。

当我们需要构造的产品比较复杂时，可以将原来**简单工厂实例化对象的过程抽象成方法**。

**工厂方法模式**：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将**对象的实例化推迟到子类**；

```java
public class BJCheesePizza extends Pizza {
    @Override
    public void prepare() {
        setName("北京奶酪披萨");
        System.out.println(" 准备北京奶酪");
    }
}
//其他产品以此类推
```

将订单类改写为抽象订单类，

```java
public abstract class OrderPizza {

    abstract Pizza cratetePizza(String orderTpye);

    //构造器
    public OrderPizza() {
        Pizza pizza = null;
        String orderType;
        do {
            orderType = getType();
            //具体实现由子类完成
            pizza = cratetePizza(orderType);
            //输出pizza
            if(Objects.nonNull(pizza)){
                pizza.prepare();
                pizza.bake();
                pizza.cut();
                pizza.bake();
            } else {
                System.out.println(" 订购披萨失败");
            }
        } while (true);
    }
}
```

然后由子类去实现具体的订单（不需要独立的工厂类了）

```java
public class BJOrderPizza extends OrderPizza {
    @Override
    Pizza cratetePizza(String orderTpye) {
        Pizza pizza = null;
        if ("cheese".equals(orderTpye)) {
            pizza = new BJCheesePizza();
        } else if("pepper".equals(orderTpye)){
            pizza = new BJPepperPizza();
        }
        return pizza;
    }
}
```

### 

## 抽象工厂模式

