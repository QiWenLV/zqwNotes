## 前奏

### 响应式到底是什么?

现实生活中，当我们听到有人喊我们的时候，我们会对其进行响应，也就是说，我们是**基于事件驱动模式**来进行的编程。

所以这个过程其实就是对于所产生事件的下发，我们的消费者对其进行的一系列的消费从这个角度，我们可以思考，整个代码的设计我们应该是针对于消费者来讲的，比如看电影，有些画面我们不想看，那就闭上眼睛，有些声音不想听，那就捂上耳朵，说白了，就是对于消费者的增强包装，我们将这些复杂的逻辑给其拆分，然后分割成一个个的小任务进行封装， 于是就有了诸如filter、map、skip、im it等操作。

### 并发与并行的关系

可以这么说， 并发很好的利用了CPU时间片的特性， 也就是操作系统选择并运行一个任务， 接着在下一个时间片会运行另一个任务，并把前一个任务设置成等待状态。

其实这里想表达的是并发并不意味着并行。

具体来举几个情况：

- 有时候多线程执行会提高应用程序的性能， 而有时候反而会降低程序的性能。这在关于JDK中其Stream API的使用上体现的很明显，如果任务量很小，而我们又使用了并行流，反而降低了性能。
- 我们在多线程编程中可能会同时开启或者关闭多个线程，这会产生的很多性能开销，这也降低了程序性能。
- 当我们的线程同时都在等待IO过程， 此时并发也就可能会阻塞CPU资源， 其造成的后果不仅仅是用户在等待结果， 同时会浪费CPU的计算资源。
- 如果几个线程共享了一个数据，情况就变得有些复杂了，我们需要考虑数据在各个线程中状态的一致性。为了达到这个目的， 我们很可能会使用Synchronized或者是lock来解决。

现在， 应该对并发有一定的认知了吧。并发是一个很好的东西， 但并不一定会实现并行。并行是在多个CPU核心上的同一时间运行多个任务或者一个任务分为多块执行(如Fork Join) 。单核CPU的话就不要考虑了。补充一点， 实际上多线程就意味着并发， 但是并行只发生在当这些线程在同一时间调度分配在不同CPU上执行。也就是说，并行是并发的一种特定的形式。往往我们一个任务里会产生很多元素，然而这些个元素在不做操作的情况下大都只能在当前线程中操作， 要么我们就要对其进行Fork Join， 但这些对于我们很多程序员来讲有时候很不好操作控制， 上手难度有些高， 响应式的话， 我们可以简单的通过其调度API就可以轻松做到事件元素的下发分配， 其内部将每个元素包装成一个任务提交到线程池中，我们可以根据是否是计算型任务还是IO类型的任务来选择相应的线程池。这里， 需要强调一下：**线程只是一个对象而已**， 不要把其想象成cpu中的某一个执行核心， 这是很多人都在犯的错， cpu时间片切换执行这些个线程。



### 响应式中的背压到底是一种怎样的理解

用一个不算很恰当的中国的成语来讲，就是承上启下。为了更好的解释，我们来看一个场景，大坝，在洪水时期，下游没有办法一下子消耗那么多水，大坝在此的作用就是拦截洪水，并根据下游的消耗情况酌情排放，再者，父亲的背，我们小时候，社会上很多的事情首先由父亲用自己的背来帮我们来扛起，然后根据我们自身的能力来适当的下发给我们压力，也就是说，背压应该写在连接元素生产者和消费者的一个地方，即**生产者和消费者的连线者**。然后，通过这里的描述，背压应该具有承载元素的能力，也就是其必须是一个**容器**的，而且**元素的存储与下发应该具有先后的**，那么使用**队列**则是最适合不过了。

### 响应式的特点

响应式编程实际上是一种设计规范，这套规范主要遵守以下4个原则

- 高可变
- 高响应
- 高容错
- 错误处理

消息驱动和事件驱动的系统。

- 异步流处理
- 非阻塞背压模式

## 响应式开发工具库

已经有很多工具库实现了Reactive Streams的标准， 包括Akka、SpringReactor、RxJava、Streams、Vert.x等等。下面就挑几个简单介绍下， 在后面两章会重点介绍RxJava和Reactor.

SpringReactor：需要java8，支持完整的响应式编程

RxJava：需要java6，仅仅支持部分响应式编程

## RxJava

通过官方github可知， RxJava是使用Java开发的专门针对jvm的一种Reactve扩展工具， 通过它可以轻松的在服务端实现并发操作。RxJava目的就是为了处理客户端越来越复杂的请求， 在服务端通过并行计算快速执行解决请求。接下来我们开始了解其到底是怎么一回事，作为数据的消费者，我们会对过来的数据做出各种反应。有句话说的好，跳出三界之外，不在五行之中，当我们以上帝视角来看这件事的时候，其实就是一个观察者设计模式的实际体现。Reactive基于影院里的电影(Observable) 提供的内容(生产者数据) 传播给订阅者Observers， 然后Observer做出其相应的反应。

结合上面的场景， 对RxJava所涉及的要点进行解释：

- Observable：被观察者，事件源。Observable会发出一定数量的元素， 可能会发送成功， 也可能在这个过程中出现状况而发送失败。 同一时间Observable可以有多个订阅者。
- Observer或Subscriber：表示消费者， 通过监听Observable来消费Observable所发送的元素，
- Methods：表示一系列操作， 修改组合数据的API：
- on Next() ：当一个元素从Observable发送出去的时， 通过这个方法可以调用每一个Subscriber.
- on Complete() ：当Observable成功发送完所有数据后， 会调用这个方法来收尾，
- on Error() ：当Observable数据发送过程中出现错误的状况时， 会调用这个方法结束发送并返回一个error。

一个Observable可以发出零个或者多个事件，知道结束或者出错。每发出一个事件，就会调用它的Subscriber的`onNext()`方法，最后调用`Subscriber.onNext()`或者`Subscriber.onError()`结束。



#### 传统的MVC编程和响应式编程的区别

![](https://wendy-image.oss-cn-shanghai.aliyuncs.com/19-07-25/1564030483172.png)

传统的调用Service是阻塞的。

响应式调用Service最后返回的不是计算接口，而是Flux（相当于票据），你可以随时拿着Flux来查询Service的计算进度，最后可以更加Flux获取计算结果。程序不会在调用时阻塞，而是继续执行。

## 应用

举例：

- Observable可以是一个数据库查询，Subscriber用来显示查询结果
- Observable可以是屏幕上的点击事件，Subscriber用来响应点击事件
- Observable可以是一个网络请求，Subscriber用来显示请求结果。

在java中大多数接口和API都是阻塞式的交互。从高性能的视角看，任何阻塞点都可能导致性能的退步。而响应式编程其天然就是非阻塞的，当数据准备完成后自动触发下一个动作而不是等待数据完成。这种思想再结合异步化编程使得我们在统一线程模型，降低多线程编程成本的同时提升整个系统的吞吐量。

- 以前一个线程中执行完所有的computation任务和IO任务如今需要
- computation任务和IO任务分离进行处理（CPU只关注computation任务）

### 实践1

根据订单号需查询：商品信息、商品详情（需要更新缓存）、浏览量、留言信息

```java

//根据订单号查订单
Flowable<Order> orderFlow = Flowable.fromCallable(() -> queryOrder(orderId));
//查商品
Flowable<Item> itemFlow = orderFlow.flatMap(order -> Flowable.fromCallable(() -> queryItem(order.getId())));
//查询商品相关信息
Flowable<Detail> detailFlow = itemFlow.flatMap(item -> {
   //浏览量
   Flowable<Long> pvFlow = Flowable.fromCallable(() -> queryItemPv(item.getId()));
   //留言
   Flowable<Comment> commentFlow = Flowable.fromCallable(() -> queryItemComment(item.getId()));
   //浏览，留言，商品共同组成detail
   return Flowable.zip(pvFlow,commentFlow,(pv,comment) -> buildItemDetail(item,pv,comment));
});
//更新缓存（doOnNext不会对流的结果造成任何影响，只是触发一个操作）
detailFlow.doOnNext(detail -> cache(detail));
```

### 实践2

```
Response response=Observable.zip(
    callAsync(()->updateStock()),
    callAsync(()->updatPayHistroy()),
    callAsync(()->updateOrder()),
    (response1,response2,response3)-> response()

).blockingGet();


```

